%
% \VignetteIndexEntry{A demonstration of the use of Synapse Tables}
\documentclass[a4paper]{article}
\usepackage{Sweave}

\title{How to Use Synapse Tables}
\author{brucehoff}

\begin{document}
\maketitle
Synapse allows you to create, modify and query tabular data.  You provide data
in a data frame or csv file.


Begin with a data frame in your session:
\begin{verbatim}
df<-data.frame("n"=c(1.1, 2.2, 3.3), 
		"c"=c("foo", "bar", "bar"), 
		"i"=as.integer(c(10,10,20)))
\end{verbatim}
This convenience function creates table columns from your data frame:
\begin{verbatim}
tcresult<-as.tableColumns(df)
cols<-tcresult$tableColumns
\end{verbatim}
('as.TableColumns' uploads your table in order to do its job.  It
returns the ID of the uploaded file for later use.)
\begin{verbatim}
fileHandleId<-tcresult$fileHandleId
\end{verbatim}
You may adjust the column models before defining the table schema.
See "?TableColumn" for the available slots.
\begin{verbatim}
cols[[2]]@maximumSize<-as.integer(20)
\end{verbatim}
Now store the Table schema in Synapse (using your own Project ID in place of
"syn12345", below):
\begin{verbatim}
projectId<-"syn12345"
schema<-TableSchema(name="aschema", parent=projectId, columns=cols)
table<-Table(schema, fileHandleId)
table<-synStore(table, retrieveData=TRUE)
\end{verbatim}
Query the table:
\begin{verbatim}
schemaId<-propertyValue(table@schema, "id")
queryResult<-synTableQuery(sprintf("select * from %s where c='bar'", schemaId))
\end{verbatim}
The query result is a Table having a data frame in the 'values' slot. Now update
the table and store it:
\begin{verbatim}
queryResult@values[2,"n"]<-pi
table<-synStore(queryResult, retrieveData=TRUE)
table@values
\end{verbatim}
To add more rows, put the additional rows in another data frame, embed in a Table,
and call 'synStore', as shown:
\begin{verbatim}
moreData<-data.frame("n"=c(7.7, 8.8, 9.9), 
	"c"=c("moar", "stuff", "here"), 
	"i"=as.integer(c(100,90,80)))
tableToAppend<-Table(schema, moreData)
table<-synStore(tableToAppend, retrieveData=TRUE)
table@values
           n     c   i
0_0 1.100000   foo  10
1_1 2.200000   bar  10
2_1 3.141593   bar  20
3_1 7.700000  moar 100
4_1 8.800000 stuff  90
5_1 9.900000  here  80
\end{verbatim}
You can delete selected rows from the table:
\begin{verbatim}
rowsToDelete<-synTableQuery(sprintf("select * from %s where c='foo'", schemaId))
synDeleteRows(rowsToDelete)
\end{verbatim}
You can also delete the entire table:
\begin{verbatim}
synDelete(schemaId)
\end{verbatim}


Table creation and retrieval can be done with files on disk.  No need to load
the data into memory first.
First we create a csv file to use:
\begin{verbatim}
df<-data.frame("n"=c(1.1, 2.2, 3.3), 
	"c"=c("foo", "bar", "bar"), 
	"i"=as.integer(c(10,10,20)))
file<-tempfile()
write.csv(df, file, row.names=FALSE)
rm(df)
\end{verbatim}
Now we proceed using the created file only:
\begin{verbatim}
tcresult<-as.tableColumns(df)
cols<-tcresult$tableColumns
fileHandleId<-tcresult$fileHandleId
schema<-TableSchema(name="aschema", parent=projectId, columns=cols)
table<-Table(schema, fileHandleId)
table<-synStore(table, retrieveData=FALSE)
schemaId<-propertyValue(table@schema, "id")
queryResult<-synTableQuery(sprintf("select * from %s where c='bar'", schemaId), 
loadResult=FALSE)
queryResult@filePath
\end{verbatim}
\end{document}
The returned file path contains the query results.
